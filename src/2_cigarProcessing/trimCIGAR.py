#!/usr/bin/env python3
import pandas as pd
import numpy as np
import logging
import re
import argparse
from utils import getIntersect

# Argparse setup
parser = argparse.ArgumentParser(description = "Extract SD regions based on trimmed CIGAR.")
parser._optionals.title = "Options"
# parser.add_argument("command", metavar = "cmd", type = str, choices = ["trim"], help = "command to perform (eg. trim)")
parser.add_argument("-i", "--input", type = str, required = True, help = "input BED file generated by BISER")
parser.add_argument("-o", "--output", type = str, required = True, help = "output path of result")
parser.add_argument("-f", "--fraglen", type = int, default = 300, help = "expected fragment length (default: 300)")
parser.add_argument("-g", "--gaplen", type = int, default = 10, help = "small gap cutoff value (default: 10)")
parser.add_argument("-v", "--verbose", type = str, default = "INFO", help = "verbosity level (default: INFO)")
args = parser.parse_args()
logging.basicConfig(format='[%(asctime)s] %(levelname)s: %(message)s', datefmt='%a %b-%m %I:%M:%S%P',
                    level = args.verbose.upper())

def lr_trim(cigar_arr, blocks):
    '''
    This function trims all leading and trailing indels and returns the modified block by reference.
    '''
    if blocks == None:
        return
    first = blocks[0]
    last = blocks[-1]
    if cigar_arr[first, 1] != 'M':
        logging.debug("Removed {}".format(cigar_arr[first]))
        np.delete(cigar_arr, first)
        blocks.pop(0)
        lr_trim(cigar_arr, blocks)
    elif cigar_arr[last, 1] != 'M':
        logging.debug("Removed {}".format(cigar_arr[last]))
        np.delete(cigar_arr, last)
        blocks.pop(-1)
        lr_trim(cigar_arr, blocks)
    else:
        return
                
def breakDownCigar(Cigar: str):
    '''
    This function takes CIGAR string (23M8D9M) and returns a list of tuples [(23, M), (8, D), ...].
    '''
    lengths = [int(s) for s in re.findall('[0-9]+', Cigar)]
    chars = re.findall('[A-Z]+', Cigar)
    
    return list(zip(lengths, chars))

# Recursive function to extend
def r_extend(cigar_arr, index: int, blocks = [], penalty = 0, small_gap_cutoff = 10, cur_len = 0, frag_len = 300):
    '''
    For any index _idx, the function looks for a long gapped alignment towards its right hand side and returns the list of indices as a block.
    Note: Left extension is not implemented to facilitate scoring algorithm. (i.e. Decide which CIGAR block to take)
    '''
    if cigar_arr[index, 1] == 'M':
        cur_len += cigar_arr[index, 0].astype(int)
        blocks.append(index)
    elif cigar_arr[index, 1] in {'D', 'I', 'N', 'S'}:
        penalty += cigar_arr[index, 0].astype(int)
        if penalty <= small_gap_cutoff:
            blocks.append(index)
        elif cur_len >= frag_len:
            return sorted(blocks)
        else:
            return None
    
    if index < len(cigar_arr) - 1:
        return r_extend(cigar_arr, index + 1, blocks = blocks, penalty = penalty, cur_len = cur_len)
    elif cur_len >= frag_len and len(blocks) == 1:
        return blocks
    elif cur_len >= frag_len and index == len(cigar_arr) - 1:
        return blocks

def getBlockFromCigar(cigar: list, frag_len = 300, small_gap_cutoff = 10):
    '''
    This function takes CIGAR string and extract blocks (list of tuples) from it.
    Blocks are either long fragments of match / mismatch OR long fragments intercalated with small indels.
    If no valid long fragments / small indels are detected, the function returns None.
    '''
    cigar_arr = np.array(cigar)
    long_match_conditions = [ (cigar_arr[:, 1] == 'M') & (cigar_arr[:, 0].astype(int) >= frag_len) ]
    indel_conditions = [ (cigar_arr[:, 1] == 'D') | (cigar_arr[:, 1] == 'I') | (cigar_arr[:, 1] == 'S') | (cigar_arr[:, 1] == 'N') ]
   
    # Add indices to each element
    __idx = np.array(range(0, len(cigar_arr), 1))[...,None]
    cigar_arr = np.append(cigar_arr, __idx, 1)
    
    # Extract blocks
    long_match_blocks = cigar_arr[np.all(long_match_conditions, axis = 0)]
    indels_blocks = cigar_arr[np.all(indel_conditions, axis = 0)]
    small_indels = cigar_arr[np.all(indel_conditions & (cigar_arr[:, 0].astype(int) <= 10), axis = 0)]

    raw_blocks = []
    for start in range(0, len(cigar_arr)):
        raw_block = r_extend(cigar_arr, start, blocks = [])
        if raw_block != None:
            lr_trim(cigar_arr, raw_block)
            logging.debug("Appending {}".format(raw_block))
            raw_blocks.append(raw_block)
    intersect = getIntersect(raw_blocks)
    blocks = []
    for tgt in scoreBlock(cigar_arr, intersect):
        blocks.append(tgt)

    if long_match_blocks.shape[0] > 0:
        logging.info("{} long fragments detected.".format(long_match_blocks.shape[0]))

        ret = []
        selected_long = long_match_blocks[:, 2].astype(int).tolist()
        for block in blocks:
            for _idx in block:
                if _idx in selected_long:
                    ret.append(block)
                    break
        return ret
    elif small_indels.shape[0] > 0:
        logging.info("{} consecutive small indels detected.".format(small_indels.shape[0]))
        return sorted(blocks)
    else:
        return None

def trim(raw_df, frag_len = 300, small_gap_cutoff = 10):
    '''
    This is the main driver trimming function.
    '''
    # Extract data from BISER output
    idx_all = raw_df.index
    ref_start_all = raw_df.iloc[:, 1]
    ref_end_all = raw_df.iloc[:, 2]
    query_start_all = raw_df.iloc[:, 4]
    query_end_all = raw_df.iloc[:, 5]
    ref_strand_all = raw_df.iloc[:, 8]
    query_strand_all = raw_df.iloc[:, 9]
    cigar_string_all = raw_df.iloc[:, 12]
    
    cur = []
    for idx, ref_start, ref_end, query_start, query_end, ref_strand, query_strand, cigar_string in zip(idx_all, ref_start_all, ref_end_all, query_start_all, query_end_all, ref_strand_all, query_strand_all, cigar_string_all):
        cigar = breakDownCigar(cigar_string)
        blocks = getBlockFromCigar(cigar, frag_len = frag_len, small_gap_cutoff = small_gap_cutoff)
        logging.debug("Extracted block indices : {}".format(blocks))
        if blocks is None:
            logging.warning("No blocks extracted!")
            continue
        all_coord = list(trimCigarCoord(cigar, blocks, ref_start, ref_end, query_start, query_end, ref_strand, query_strand))
        
        # Update dataframe and create records
        for coord, block in zip(all_coord, blocks):
            tmp = raw_df.iloc[idx, :].to_list()
            tmp[1] = coord[0]
            tmp[2] = coord[1]
            tmp[4] = coord[2]
            tmp[5] = coord[3]
            tmp[10] = max(coord[1] - coord[0], coord[3] - coord[2])
            tmp[11] = sum([cigar[i][0] for i in block])
            tmp[12] = "".join([str(cigar[i][0]) + cigar[i][1] for i in block])
            cur.append(tmp)
    
    ret = pd.DataFrame(cur)
    logging.info("Total number of regions : {}".format(ret.shape[0]))
    
    return ret

def getCigarLength(cigar: list, *idx, ref_start = 0, query_start = 0):

    ref_consume, query_consume = ref_start, query_start
    for _idx in idx:
        if cigar[_idx][1] == 'M':
            ref_consume += cigar[_idx][0]
            query_consume += cigar[_idx][0]
        elif cigar[_idx][1] == 'D' or cigar[_idx][1] == 'N':
            ref_consume += cigar[_idx][0]
        elif cigar[_idx][1] == 'I' or cigar[_idx][1] == 'S':
            query_consume += cigar[_idx][0]
    
    return (ref_consume, query_consume)

def trimCigarCoord(cigar: list, blocks: list, ref_start, ref_end, query_start, query_end, ref_strand, query_strand):

    for block in blocks:
        first, *others = block
        (ref_consume, query_consume) = getCigarLength(cigar, first, *others)
        (ref_up, query_up) = getCigarLength(cigar, *range(0, first, 1))
        
        if ref_strand == "+" and query_strand == "+":
            ref_new_start = ref_start + ref_up
            ref_new_end = ref_new_start + ref_consume
            query_new_start = query_start + query_up
            query_new_end = query_new_start + query_consume
        elif ref_strand == "-" and query_strand == "+":
            ref_new_end = ref_end - ref_up
            ref_new_start = ref_new_end - ref_consume
            query_new_start = query_start + query_up
            query_new_end = query_new_start + query_consume
        elif ref_strand == "+" and query_strand == "-":
            ref_new_start = ref_start + ref_up
            ref_new_end = ref_new_start + ref_consume
            query_new_end = query_end - query_up
            query_new_start = query_new_end - query_consume
        
        yield (ref_new_start, ref_new_end, query_new_start, query_new_end)
    
def scoreBlock(cigar_arr, intersectBlock):
   
    for block in intersectBlock:
        score = []
        for sub_block in block: 
            running_score = 0
            for idx in sub_block:
                if cigar_arr[idx, 1] == 'M':
                    running_score += cigar_arr[idx, 0].astype(int)
            score.append(running_score)
        target = score.index(max(score))
        yield block[target]
        
def main():
    
    raw_df = pd.read_csv(args.input, sep = "\t", header = None)
    logging.info("Total number of reads = {}".format(raw_df.shape[0]))
    ret = trim(raw_df, frag_len = args.fraglen, small_gap_cutoff = args.gaplen)
    ret.to_csv(args.output, sep = "\t", index = False, header = None, mode = 'w')
    logging.info("Successfully trimmed BED!")
    
    return

if __name__ == "__main__":
    main()